-- 1. Create custom types for roles and permissions
CREATE TYPE public.app_role AS ENUM ('admin', 'user');
CREATE TYPE public.app_permission AS ENUM (
  'categories.create',
  'categories.update', 
  'categories.delete',
  'videos.create',
  'videos.update',
  'videos.delete',
  'leads.create', 
  'leads.update',
  'leads.delete'
);

-- 2. Create tables to track user roles and permissions
CREATE TABLE public.user_roles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  role app_role NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (user_id, role)
);

CREATE TABLE public.role_permissions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role app_role NOT NULL,
  permission app_permission NOT NULL,
  UNIQUE (role, permission)
);

COMMENT ON TABLE public.user_roles IS 'Application roles for each user.';
COMMENT ON TABLE public.role_permissions IS 'Application permissions for each role.';

-- 3. Insert default roles and permissions
INSERT INTO public.role_permissions (role, permission)
VALUES
  -- Admin has all permissions
  ('admin', 'categories.create'),
  ('admin', 'categories.update'),
  ('admin', 'categories.delete'),
  ('admin', 'videos.create'),
  ('admin', 'videos.update'),
  ('admin', 'videos.delete'),
  ('admin', 'leads.create'),
  ('admin', 'leads.update'),
  ('admin', 'leads.delete'),
  
  -- Regular users have limited permissions
  ('user', 'categories.create'),
  ('user', 'videos.create'),
  ('user', 'videos.update'),
  ('user', 'leads.create'),
  ('user', 'leads.update');

-- 4. Create the custom access token hook function
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event JSONB)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
STABLE
AS $$
DECLARE
  claims JSONB;
  user_role public.app_role;
BEGIN
  -- Fetch the user role from the user_roles table
  SELECT role INTO user_role 
  FROM public.user_roles 
  WHERE user_id = (event->>'user_id')::UUID;
  
  claims := event->'claims';
  
  IF user_role IS NOT NULL THEN
    -- Set the claim
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
  ELSE
    -- Default to 'user' role if not explicitly set
    claims := jsonb_set(claims, '{user_role}', '"user"');
  END IF;
  
  -- Update the 'claims' object in the original event
  event := jsonb_set(event, '{claims}', claims);
  
  -- Return the modified event
  RETURN event;
END;
$$;

-- 5. Grant necessary permissions for the hook to work
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated, anon, public;

-- 6. Grant access to the user_roles table for the hook
GRANT ALL ON TABLE public.user_roles TO supabase_auth_admin;
REVOKE ALL ON TABLE public.user_roles FROM authenticated, anon, public;

-- 7. Create policy for the auth admin to read user roles
CREATE POLICY "Allow auth admin to read user roles" 
ON public.user_roles
AS PERMISSIVE 
FOR SELECT
TO supabase_auth_admin
USING (TRUE);

-- 8. Create the authorize function for RLS policies
CREATE OR REPLACE FUNCTION public.authorize(
  requested_permission app_permission
) 
RETURNS BOOLEAN
LANGUAGE plpgsql
STABLE 
SECURITY DEFINER 
SET search_path = ''
AS $$
DECLARE
  bind_permissions INT;
  user_role public.app_role;
BEGIN
  -- Fetch user role from JWT
  SELECT (auth.jwt() ->> 'user_role')::public.app_role INTO user_role;
  
  IF user_role IS NULL THEN
    RETURN FALSE;
  END IF;
  
  -- Check if the user's role has the requested permission
  SELECT COUNT(*)
  INTO bind_permissions
  FROM public.role_permissions
  WHERE role_permissions.permission = requested_permission
    AND role_permissions.role = user_role;
    
  RETURN bind_permissions > 0;
END;
$$;

-- 9. Apply RLS policies to tables with role-based permissions
-- Categories table
ALTER TABLE categories ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow all users to view categories" 
ON categories FOR SELECT
USING (TRUE);

CREATE POLICY "Allow authorized users to create categories" 
ON categories FOR INSERT 
TO authenticated
WITH CHECK ((SELECT authorize('categories.create')));

CREATE POLICY "Allow authorized users to update categories" 
ON categories FOR UPDATE 
TO authenticated
USING (TRUE)
WITH CHECK ((SELECT authorize('categories.update')));

CREATE POLICY "Allow authorized users to delete categories" 
ON categories FOR DELETE 
TO authenticated
USING ((SELECT authorize('categories.delete')));

-- Videos table
-- Assuming RLS is already enabled for videos

CREATE POLICY "Allow authorized users to create videos" 
ON videos FOR INSERT 
TO authenticated
WITH CHECK ((SELECT authorize('videos.create')));

CREATE POLICY "Allow authorized users to update videos" 
ON videos FOR UPDATE 
TO authenticated
USING (TRUE)
WITH CHECK ((SELECT authorize('videos.update')));

CREATE POLICY "Allow authorized users to delete videos" 
ON videos FOR DELETE 
TO authenticated
USING ((SELECT authorize('videos.delete')));

-- Leads table
ALTER TABLE leads ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow all users to view leads" 
ON leads FOR SELECT
USING (TRUE);

CREATE POLICY "Allow authorized users to create leads" 
ON leads FOR INSERT 
TO authenticated
WITH CHECK ((SELECT authorize('leads.create')));

CREATE POLICY "Allow authorized users to update leads" 
ON leads FOR UPDATE 
TO authenticated
USING (TRUE)
WITH CHECK ((SELECT authorize('leads.update')));

CREATE POLICY "Allow authorized users to delete leads" 
ON leads FOR DELETE 
TO authenticated
USING ((SELECT authorize('leads.delete')));

-- 10. Helper function to assign a role to a user
CREATE OR REPLACE FUNCTION public.assign_user_role(
  p_user_id UUID,
  p_role app_role
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Insert or update the user role
  INSERT INTO public.user_roles (user_id, role)
  VALUES (p_user_id, p_role)
  ON CONFLICT (user_id, role)
  DO NOTHING;
END;
$$;

-- Grant execute to service_role (for admin operations)
GRANT EXECUTE ON FUNCTION public.assign_user_role TO service_role; 